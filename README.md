# フロント環境について

# 準備
- クライアントの制作代行の場合は、モジュール・ユーティリティのjsやmd等のソースを削除する

image-meta.jsonがバグった場合
一度現在の状況でmetaファイルの生成
build:convert-imagesで、現在のmeta状況でconvertし直し


scssの準備でいじるmixinは、hoverくらい。


build-config.jsを編集し、プロキシモード設定などを行う


jsプラグインについては、npmで管理せず、CDNを利用する方針とする
ビルドができない(クライアントの都合で)場合は、
src内のjsをそのまま使用する方法をとる。
その場合は、ビルドしないため、CDNを利用するしかない。
**フロントエンドのビルドは、
「人間が書いたJS/CSSを、ブラウザが高速・安全に実行できる形に整える作業」**です。
=> npmパッケージにするかは要検討で！！！
⭐完全自社でやるなら、入れていいと思う


# 運用
外部の制作で使用する場合は、最低限のソースを提供すること。
特に環境周りや、
jsのモジュールなど


以下のような事項はプロジェクト毎に調整すること
- jsのコンパイル有無 package.json
- scssコンパイルはlive sass を使うか、　npm で行うか
- コンパイル後の出力はdistにするのかどうするのか
- 他各種ディレクトリパス

## phpやwpについて
- フロント環境は本環境のコンテナを使用する
- phpやwpはそれ専用のコンテナにして、分離していく
- フロント関連のソースは常にこちらが最新であること。


・ホストでnode使う場合はvoltaを、docker使う場合はdockerにnode入れる
# nodeの説明

## クライアント都合でnodeが使用できない場合
・.vscode/に、settings.jsonを生成(コピペ)　⇒　cssのパスを設定する
・distディレクトリの削除
・js　⇒　そのままsrc内のjsを使用する（コンパイルしない）
・scss　⇒　dist内ではなく、src内にcss生成でOK(live sass compilerで)
・ブラウザシンクも不要 live serverで十分
⇒　もしくは、
・ブラウザシンク + scssコンパイルだけ使用する (拡張機能の動作が遅いことがあるので)
⇒　もしくは、
・ブラウザシンクのみ使用する
**php環境の場合はdockerが必要。liveserver使えないので、ブラウザシンク必須**
※**編集するファイルの場所は変わらないので、cursor各種ルールに影響はない**

## 準備 (husky)を使用する場合
★最初に、「npm run prepare」　を実行し、huskyの準備を行う (husky install)
⇒ 事前に用意された「pre-commit」を使用する
- 使用しない場合は.husky/を削除する

## huskyについて
lint-stagedを使用し、コミット時にprettierを実行するようにしている

## buildについて
npm run build　で、コンパイル処理を1回行う(画像変換は行わない。)

## watchについて
コンパイルや画像変換の監視処理のみ

## 開発時について
npm run startを実行すると、初回buildと、watch(監視)処理と、ブラウザシンクを実行する(localhost:3000)

## 各npm処理の説明 -------------------------

### convert-images
jpgやpng画像を元に、avif webp 1/2サイズの画像の生成する(sharp)
・_origin/　・・・ png jpgの変換対象ディレクトリ 元の書き出し画像をここに格納する
・avif/　・・・　変換したavif画像の出力先ディレクトリ(**基本手動では操作しない**)
・webp/　・・・　変換したwebp画像の出力先ディレクトリ(**基本手動では操作しない**)
・compression/　・・・　変換した圧縮画像の出力先ディレクトリ(**基本手動では操作しない**)
・svg/　・・・　SVG画像の格納ディレクトリ

※元画像は、Rethina対応を踏まえて、基本的には表示サイズの2倍以上のサイズを持った画像であること。
　サブ的な画像・綺麗に見えなくても許容できる画像に関しては1.5倍ないし、1倍等とする。
※imgの出し分けについては以下の順番とする
①avif
②webp
③圧縮画像
⇒
・Rethina対応のために2倍書き出し⇒avif webpの使用
・avif・webp対応外の場合、Rethinaである確立は低いと考えられるため、圧縮画像のフォールバックのみとする
(・・・運用面・品質面の両者検討の結果現状は上記とする)

**変換防止**
現時点の画像について変換をかけたくない場合は、**meta:convert-images**でmetaファイルを更新する

**チーム開発の場合の考慮**
他者が追加した画像を取り込みconvertすると、それらがすべて変更検知されるため、watchの際にmeta更新する
ただし、buildでは行わない。buildは、最終的な整合性を補完するため。現状でmeta更新したら、意味がないので。


### generate-scss-index
scssのindexファイルの自動生成・更新を行う
新規にscssファイルを追加・削除した場合に、その変更に応じてindexファイルを自動修正する
⇒　★一旦不要(各画面のエントリーファイルに個別にuse指定することにしたため)


### js
**動的インポートはなし各ページのファイルをエントリーにする(ない場合はcommon)**
jsのコンパイル・minify化等を行う
_es/配下に作業用jsファイルを格納する
EsLintは一旦使用する方向で
babelは、レガシーブラウザ版のみで使用想定
 ※そもそもこの場合、コンパイルせずに使用しても良い。(babelやtransferしないでいいならそのまま使える)

 ■プラグインについて
 一応ensureXXXXという形で、pulginをnpmで読み込んで使用する仕組みを作ったが、
 CDNでシンプルに対応するのもOK
 (cssはvendor/ にいれる想定)

■構成
・constans => グローバル定数
・modules  => モジュール その要素にしか使わない処理 **クラス名固定化しており、その要素に適用する処理**
              **「initXXXX」で初期化処理の命名統一**
・utils    => ユーティリティ関数 汎用的にページやモジュール内で使いまわせる処理
・pages    => ページ毎の処理　※ここがエントリーになる
・plugins  => プラグインのファイル格納場所

- **①BasePageClassを、クリーンアップ処理を考慮した構成にする。**
AbortContollerを仕様して、クリーンアップ管理
**仕様する画面側で、任意のタイミングでその処理を呼び出せるように**しておく
※Astroとかであれば、さらに上位のベースクラスを用意して、画面遷移前にクリーンアップを流すように初期化をする構成にしてしまえばよいかもしれない。
※React等であれば、それぞれアンマウントメソッドがあるので、そこで呼ぶイメージ

- 各ページファイルにてBasePageClassをインスタンス化する場合、セレクタには画面名のidを指定する => **各画面のルート要素には、画面名のidを付与すること**

- **②各modulesについて、BaseModuleClassを作成して、それを継承したクラスに変更する**
BaseModuleClassは、初期化とクリーンアップの構成となる。
クリーンアップについては、BasePageと同様で、bag管理で一括管理できるようにする。
インスタンス化すると初期化が行われ、画面側の破棄タイミング等で、適宜クリーンアップを呼び出して対応する。

- **③各utilsについて、全てsignalを引数で受け取るようにする。**
画面側でutilを呼ぶときには、ページ側のsignalが、
モジュールから呼ぶときはモジュールのsginalが渡る。
各utilsの処理の中では、イベント登録する場合は必ず受け取ったsignalを指定し、timeoutやInterval、プラグイン等破棄処理が必要な場合は、受け取ったsignalのabourに紐づけること。(この紐づけ自体もイベント登録になるので、{once: ture}を忘れずに)


### scss
scssのコンパイル・minify化・PostCssの処理を行う
styleLintは一旦使用しない

TABは基準値を変えてリキッド。
ある程度レイアウトの調整は必要。tabレイアウト・基準に変換してリキッドにする
tab-onlyで対応すると良い。
※もう1ポイント作ってもよいかも。

- PRESERVE_DIRECTORY_STRUCTURE で、出力ディレクトリを1階層にするか、scssと合わせるか選択できるようにした

### npmコマンド
npm run start でブラウザシンク・各コンパイル処理の実施
npm run watch:convert-images で画像変換

### フォーマッター
 - EditorConfigプラグイン + .editorconfigで、インデントや改行コード等ファイル形式の基礎設定
   ⇒ 文章のフォーマット(インデント幅, 文字コード、改行コード、最終行改行、行末スペース　くらい)
      あくまで、エディターの基礎設定を統一するもの
 - Prettier + .prettierrc + prettier(node)パッケージで、言語ごとの詳細なコードフォーマット
   ⇒ コードのフォーマット(クォート、括弧、import順、プロパティ順、Tailwindクラス順　等々)
   ⇒ .vscode/settings.jsonで使用するフォーマッターを prettierに設定すること
   ※本環境では、huskyでコミット時に整形するようにしている(が、あんまり使わない想定)